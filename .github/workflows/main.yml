# A descriptive name for the workflow, shown in the GitHub Actions UI.
name: Android Super Partition Repack (Build & Release)

# This section defines how the workflow is triggered.
on:
  # 'workflow_dispatch' allows you to run this workflow manually from the
  # "Actions" tab in your GitHub repository.
  workflow_dispatch:
    # 'inputs' defines the parameters you can provide when running the workflow manually.
    inputs:
      for_samsung_a04s:
        description: 'Use pre-configured Samsung A04s firmware? (Ignores Stock Firmware URL input)'
        required: true
        type: boolean
        default: false
      stock_firmware_url:
        description: 'URL to the stock firmware (Direct HTTP, MEGA.nz, etc.). Required if A04s is not selected.'
        required: false # Validated in the first step.
        type: string
      custom_system_url:
        description: 'Custom ROM download URL (.img, .img.xz, .zip supported)'
        required: true
        type: string
      upload_to_release:
        description: 'Upload the final artifact as a GitHub Release?'
        required: true
        type: boolean
        default: true
      no_flash_flag:
        description: 'The flag to prevent the script from trying to flash (e.g., -n, --no-flash). Leave blank if none.'
        required: false
        type: string
      empty_product:
        description: 'Use empty product.img (-e flag)'
        required: false
        type: boolean
        default: false
      empty_system_ext:
        description: 'Use empty system_ext.img (-x flag)'
        required: false
        type: boolean
        default: false
      silent_mode:
        description: 'Silent mode for the script (-s flag)'
        required: false
        type: boolean
        default: true
      writable:
        description: 'Make partitions writable (-w flag)'
        required: false
        type: boolean
        default: false
      purge_all:
        description: 'Purge repacksuper directory after use (-p flag)'
        required: false
        type: boolean
        default: true

# A workflow is made up of one or more 'jobs'.
jobs:
  repack-super:
    # 'runs-on' specifies the type of virtual machine to run the job on.
    runs-on: ubuntu-latest
    # 'permissions' are required to create GitHub Releases.
    permissions:
      contents: write
    # 'steps' are a sequence of tasks that will be executed as part of the job.
    steps:
    # This step checks out a copy of your repository onto the runner.
    - name: Checkout repository
      uses: actions/checkout@v4

    # --- START OF DISK SPACE CLEANUP ---
    - name: Free disk space
      run: |
        echo "Initial disk space:"
        df -h
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
        sudo docker image prune --all --force
        echo "Disk space after manual cleanup:"
        df -h

    # This step installs the necessary dependencies, including gdown for Google Drive.
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y android-sdk-libsparse-utils tar xz-utils liblz4-tool unzip p7zip-full file wget curl megatools f2fs-tools python3-pip
        pip install gdown

    # This step validates user inputs to ensure the workflow can proceed.
    - name: Validate Inputs
      run: |
        if [[ "${{ github.event.inputs.for_samsung_a04s }}" == "false" && -z "${{ github.event.inputs.stock_firmware_url }}" ]]; then
          echo "✗ Error: Stock Firmware URL is required when 'For Samsung A04s' is not selected."
          exit 1
        fi
        echo "==> Input validation passed."

    # This step ensures the main script is present and executable.
    - name: Verify and Prepare Script
      run: |
        if [ ! -f "./repacksuper.sh" ]; then echo "✗ Error: repacksuper.sh not found" && exit 1; fi
        chmod +x ./repacksuper.sh

    # This step creates a dedicated directory for all the work.
    - name: Create working directory
      run: mkdir -p work

    # This step generates a unique hash of the firmware URL for caching (only if not A04s).
    - name: Generate Firmware URL Hash for Cache
      if: github.event.inputs.for_samsung_a04s == 'false'
      id: generate_hash
      run: |
        echo "fw_hash=$(echo -n "${{ github.event.inputs.stock_firmware_url }}" | md5sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT

    # This step caches the downloaded stock firmware to speed up subsequent runs (only if not A04s).
    - name: Cache Stock Firmware
      if: github.event.inputs.for_samsung_a04s == 'false'
      id: cache-stock
      uses: actions/cache@v4
      with:
        path: work/stock_firmware.zip
        key: ${{ runner.os }}-stock-${{ steps.generate_hash.outputs.fw_hash }}

    # This step downloads and extracts the stock super.img based on the user's choice.
    - name: Download and Extract Stock Firmware
      run: |
        cd work
        if [[ "${{ github.event.inputs.for_samsung_a04s }}" == "true" ]]; then
          echo "==> Using pre-configured Samsung A04s firmware."
          gdown --output stock_firmware.zip '1j27zk_T6cfUcJ-AQHX9DeeXLxQaMOM8p'
        else
          echo "==> Using provided Stock Firmware URL."
          FIRMWARE_URL="${{ github.event.inputs.stock_firmware_url }}"
          if [ "${{ steps.cache-stock.outputs.cache-hit }}" != 'true' ]; then
            echo "==> No cache hit. Downloading stock firmware..."
            if [[ $FIRMWARE_URL == *"mega.nz"* ]]; then megadl -o stock_firmware.zip "$FIRMWARE_URL"; else wget --user-agent="Mozilla/5.0" --content-disposition -O stock_firmware.zip --tries=5 --wait=10 "$FIRMWARE_URL"; fi
          else
            echo "==> Stock firmware cache was successfully restored."
          fi
        fi
        if [ ! -s "stock_firmware.zip" ]; then echo "✗ CRITICAL ERROR: Failed to download or find stock firmware." && exit 1; fi
        AP_FILENAME=$(unzip -l "stock_firmware.zip" | grep -i -o -E "AP_.*\.tar\.md5" | head -n 1)
        if [ -z "$AP_FILENAME" ]; then echo "✗ Error: AP file not found."; unzip -l "stock_firmware.zip"; exit 1; fi
        unzip -o -j "stock_firmware.zip" "$AP_FILENAME"
        rm "stock_firmware.zip"
        tar -xvf "$AP_FILENAME" --wildcards '*super.img*.lz4'
        rm "$AP_FILENAME"
        SUPER_LZ4=$(ls *super.img*.lz4 | head -n 1)
        lz4 -d "$SUPER_LZ4" stock_super_sparse.img
        rm "$SUPER_LZ4"
        if [ ! -f "stock_super_sparse.img" ]; then echo "✗ Error: Failed to create sparse stock_super.img." && exit 1; fi

    # This step downloads and prepares the custom system.img.
    - name: Download and Prepare Custom system.img
      run: |
        cd work
        wget -O custom_rom_package "${{ github.event.inputs.custom_system_url }}"
        if [ ! -s "custom_rom_package" ]; then echo "✗ Error: Failed to download custom ROM." && exit 1; fi
        FILE_TYPE=$(file -b custom_rom_package)
        case "$FILE_TYPE" in
          *"XZ compressed data"*)      mv custom_rom_package c.img.xz && unxz c.img.xz && mv c.img custom_system.img ;;
          *"Zip archive data"*)
            unzip -o custom_rom_package ; rm custom_rom_package
            SYSTEM_IMG_FILE=$(find . -maxdepth 1 -name "system.img" -o -name "system.raw.img" | head -n 1)
            if [ -z "$SYSTEM_IMG_FILE" ]; then echo "✗ Error: system.img not found in ZIP." && exit 1; fi
            mv "$SYSTEM_IMG_FILE" custom_system.img ;;
          *"7z archive data"*)
            7z x custom_rom_package ; rm custom_rom_package
            SYSTEM_IMG_FILE=$(find . -maxdepth 1 -name "system.img" -o -name "system.raw.img" | head -n 1)
            if [ -z "$SYSTEM_IMG_FILE" ]; then echo "✗ Error: system.img not found in 7z archive." && exit 1; fi
            mv "$SYSTEM_IMG_FILE" custom_system.img ;;
          *)                            mv custom_rom_package custom_system.img ;;
        esac
        if [ ! -f "custom_system.img" ]; then echo "✗ Error: custom_system.img not created." && exit 1; fi

    # REVISED STEP: This now gracefully handles the simg2img error by attempting a conversion
    # and using the original file if the conversion fails. This is the most robust method.
    - name: Ensure Raw Image (by attempting conversion)
      run: |
        cd work
        echo "==> Attempting to convert custom_system.img to raw (if it is sparse)..."
        # Create a backup of the original image.
        mv custom_system.img custom_system.original.img
        
        # Attempt the conversion. 'if simg2img...' will check the exit code of the command.
        if simg2img custom_system.original.img custom_system.img; then
          # This block executes if simg2img was successful (exit code 0).
          echo "==> Success: Image was sparse and has been converted to raw."
          rm custom_system.original.img # Clean up the backup.
        else
          # This block executes if simg2img failed (e.g., "Invalid sparse file format").
          echo "==> Info: simg2img failed, which is expected for a raw image. Using the original file."
          # Restore the original image since the conversion failed.
          mv custom_system.original.img custom_system.img
        fi
        echo "==> Image is ready for the next step."

    # This step modifies the build.prop file using multiple fallback methods
    - name: Modify build.prop for Branding (Multi-Method Approach)
      run: |
        cd work
        echo "==> Attempting build.prop modification with multiple methods..."
        
        # Create an advanced script that tries multiple approaches
        cat > advanced_modify.sh << 'EOF'
        #!/bin/bash
        
        IMAGE_PATH="/host/custom_system.img"
        SUCCESS=false
        
        echo "==> Method 1: Standard loop mount with explicit loop device"
        # Try creating explicit loop device first
        LOOP_DEV=$(losetup -f)
        echo "==> Using loop device: $LOOP_DEV"
        if losetup "$LOOP_DEV" "$IMAGE_PATH"; then
          echo "==> Loop device created successfully"
          
          # Detect filesystem
          FS_TYPE=$(blkid -o value -s TYPE "$LOOP_DEV" 2>/dev/null || echo "unknown")
          echo "==> Filesystem detected on loop device: $FS_TYPE"
          
          if [[ "$FS_TYPE" == "ext4" || "$FS_TYPE" == "f2fs" ]]; then
            mkdir -p /mnt_system
            if mount -t "$FS_TYPE" "$LOOP_DEV" /mnt_system; then
              echo "==> Mount successful with explicit loop device"
              if [ -f "/mnt_system/system/build.prop" ]; then
                echo "==> Found build.prop, modifying..."
                sed -i 's|ro.build.id=.*|ro.build.id=Built.By.Minh2077.Script|g' /mnt_system/system/build.prop
                echo "==> build.prop modified successfully!"
                SUCCESS=true
              fi
              sync
              umount /mnt_system
              echo "==> Unmounted successfully"
            else
              echo "==> Failed to mount with explicit loop device"
            fi
          fi
          losetup -d "$LOOP_DEV"
        else
          echo "==> Failed to create loop device"
        fi
        
        if [ "$SUCCESS" = false ]; then
          echo "==> Method 2: Using e2fsck to check and potentially fix image"
          # Sometimes the image needs a filesystem check
          if command -v e2fsck >/dev/null 2>&1; then
            echo "==> Running e2fsck to check/fix image..."
            e2fsck -f -y "$IMAGE_PATH" || echo "==> e2fsck completed (exit code $?)"
            
            # Try mounting again after fsck
            LOOP_DEV=$(losetup -f)
            if losetup "$LOOP_DEV" "$IMAGE_PATH"; then
              mkdir -p /mnt_system
              if mount -t ext4 "$LOOP_DEV" /mnt_system; then
                echo "==> Mount successful after e2fsck"
                if [ -f "/mnt_system/system/build.prop" ]; then
                  sed -i 's|ro.build.id=.*|ro.build.id=Built.By.Minh2077.Script|g' /mnt_system/system/build.prop
                  echo "==> build.prop modified successfully after e2fsck!"
                  SUCCESS=true
                fi
                sync
                umount /mnt_system
              fi
              losetup -d "$LOOP_DEV"
            fi
          fi
        fi
        
        if [ "$SUCCESS" = false ]; then
          echo "==> Method 3: Using debugfs for ext4 images (read-only approach)"
          if command -v debugfs >/dev/null 2>&1; then
            FS_TYPE=$(blkid -o value -s TYPE "$IMAGE_PATH" 2>/dev/null)
            if [ "$FS_TYPE" = "ext4" ]; then
              echo "==> Attempting to read build.prop with debugfs..."
              if echo "cat /system/build.prop" | debugfs "$IMAGE_PATH" 2>/dev/null | grep -q "ro.build.id"; then
                echo "==> Found build.prop via debugfs, but cannot modify (read-only method)"
                echo "==> Creating a note that build.prop exists but modification failed"
                echo "BUILD_PROP_EXISTS=true" >> /host/build_prop_status.txt
              fi
            fi
          fi
        fi
        
        if [ "$SUCCESS" = true ]; then
          echo "SUCCESS=true" >> /host/build_prop_status.txt
          echo "==> ✅ build.prop modification completed successfully!"
        else
          echo "SUCCESS=false" >> /host/build_prop_status.txt
          echo "==> ❌ All methods failed. This might be due to:"
          echo "    - Image corruption"
          echo "    - Unsupported filesystem"
          echo "    - Missing system partition structure"
          echo "    - Read-only filesystem (EROFS, squashfs, etc.)"
        fi
        EOF
        
        chmod +x advanced_modify.sh
        
        # Run with even more privileges and additional tools
        docker run --rm --privileged \
          --device-cgroup-rule="a *:* rmw" \
          -v "$(pwd):/host" \
          -v "$(pwd)/advanced_modify.sh:/advanced_modify.sh" \
          ubuntu:22.04 \
          bash -c "
            echo '==> Installing comprehensive toolset...'
            apt-get update -qq
            apt-get install -y -qq util-linux file e2fsprogs f2fs-tools debugfs
            echo '==> Running advanced modification script...'
            /advanced_modify.sh
          "
        
        # Check results
        if [ -f "build_prop_status.txt" ]; then
          echo "==> Checking modification results..."
          cat build_prop_status.txt
          if grep -q "SUCCESS=true" build_prop_status.txt; then
            echo "✅ Build.prop was successfully modified!"
          else
            echo "⚠️ Build.prop modification failed, but continuing with workflow..."
          fi
          rm -f build_prop_status.txt
        fi
        
        rm -f advanced_modify.sh
        echo "==> Advanced build.prop modification process completed."

    # This step prepares the command-line flags for the 'repacksuper.sh' script.
    - name: Prepare repacksuper.sh flags
      id: prepare_flags
      run: |
        FLAGS="-r $(pwd)/work"
        if [ "${{ github.event.inputs.silent_mode }}" == "true" ]; then FLAGS="$FLAGS -s"; fi
        if [ "${{ github.event.inputs.purge_all }}" == "true" ]; then FLAGS="$FLAGS -p"; fi
        if [ "${{ github.event.inputs.empty_product }}" == "true" ]; then FLAGS="$FLAGS -e"; fi
        if [ "${{ github.event.inputs.empty_system_ext }}" == "true" ]; then FLAGS="$FLAGS -x"; fi
        if [ "${{ github.event.inputs.writable }}" == "true" ]; then FLAGS="$FLAGS -w"; fi
        if [ -n "${{ github.event.inputs.no_flash_flag }}" ]; then FLAGS="$FLAGS ${{ github.event.inputs.no_flash_flag }}"; fi
        echo "flags=$FLAGS" >> $GITHUB_OUTPUT

    # This is the core step where the super partition is repacked.
    - name: Run repacksuper.sh
      run: |
        echo "==> Running repacksuper.sh with flags: ${{ steps.prepare_flags.outputs.flags }}"
        ./repacksuper.sh ${{ steps.prepare_flags.outputs.flags }} work/stock_super_sparse.img work/custom_system.img work/repacked_super.img
        rm -f work/stock_super_sparse.img work/custom_system.img

    # This step verifies, renames, and creates an uncompressed tarball.
    - name: Verify, Rename, and Create Tarball
      id: create_tarball
      run: |
        cd work
        if [ ! -f "repacked_super.img" ]; then echo "✗ Error: repacked_super.img not found." && ls -la && exit 1; fi
        mv repacked_super.img super.img
        TARBALL_NAME="repacked_super_$(date +%Y%m%d).tar"
        tar -cvf "$TARBALL_NAME" super.img
        rm super.img
        echo "tarball_path=work/$TARBALL_NAME" >> $GITHUB_OUTPUT
        echo "tarball_name=$TARBALL_NAME" >> $GITHUB_OUTPUT

    # This step uploads the final tarball as a workflow artifact.
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: repacked-super-image
        path: ${{ steps.create_tarball.outputs.tarball_path }}

    # This step creates a GitHub Release if the user selected the option.
    - name: Create GitHub Release with Artifact
      if: github.event.inputs.upload_to_release == 'true'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: repack-${{ github.run_id }}-${{ github.run_attempt }}
        name: "Repacked Super Image - ${{ github.run_id }}"
        body: |
          ## Repacked Super Image
          This release was generated automatically by the GitHub Actions workflow.
          ### Source Files
          *   **Stock Firmware:** `${{ github.event.inputs.for_samsung_a04s == 'true' && 'Pre-configured for Samsung A04s' || github.event.inputs.stock_firmware_url }}`
          *   **Custom ROM:** `${{ github.event.inputs.custom_system_url }}`
        files: ${{ steps.create_tarball.outputs.tarball_path }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      continue-on-error: true

    # This step runs at the end of the job to show final disk space.
    - name: Final Space Check
      if: always()
      run: |
        echo "Final disk space:"
        df -h
